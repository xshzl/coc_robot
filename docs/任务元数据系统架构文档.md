# 任务元数据系统架构文档

## 概述

**任务元数据系统**是一个解耦任务、数据库和UI的架构设计，通过**声明式元数据**实现任务的自描述，从而避免了修改任务时需要同步修改数据库和UI的问题。

---

## 问题背景

### 原有架构的问题

1. **任务需要持久化数据** → 每次都要手动设计数据库表结构
2. **任务需要输入参数** → 每次都要修改UI代码
3. **任务之间有依赖关系** → 没有统一的依赖管理机制

导致：**任务代码、数据库、UI三方强耦合**

---

## 新架构设计

### 核心思想

1. **任务自描述**：每个任务通过元数据声明"我需要什么参数"、"我需要存储什么状态"、"我依赖哪些任务"
2. **通用数据层**：不再为每个任务设计表，统一用KV存储（任务参数表、任务状态表）
3. **UI自动生成**：根据元数据自动生成配置表单
4. **依赖声明**：任务声明依赖关系，框架自动检查和排序

### 架构图

```
┌─────────────────────────────────────────────────────┐
│                   任务类（业务逻辑）                  │
│                                                       │
│  - 声明元数据（参数、状态、依赖）                      │
│  - 执行业务逻辑                                       │
│  - 使用 self.参数 访问参数                            │
│  - 使用 self.状态 访问状态                            │
│  - 使用 self.保存状态() 持久化状态                    │
└─────────────────┬───────────────────────────────────┘
                  │
                  │ 元数据
                  ↓
┌─────────────────────────────────────────────────────┐
│              任务元数据（声明式配置）                  │
│                                                       │
│  - 任务名称、显示名称、描述                            │
│  - 参数列表（名称、类型、默认值、UI控件）              │
│  - 状态列表（名称、类型、默认值）                      │
│  - 依赖关系（前置任务、互斥任务）                      │
└─────────┬─────────────────┬─────────────────────────┘
          │                 │
          │                 │ 自动解析
          │                 ↓
          │         ┌───────────────────┐
          │         │  UI自动生成器      │
          │         │                   │
          │         │  根据元数据生成     │
          │         │  Tkinter配置界面   │
          │         └───────────────────┘
          │
          │ 自动加载/保存
          ↓
┌─────────────────────────────────────────────────────┐
│            通用数据库（KV存储）                        │
│                                                       │
│  - 任务参数表：(机器人, 任务类名, 参数名) -> 参数值    │
│  - 任务状态表：(机器人, 任务类名, 状态键) -> 状态值    │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│            任务依赖管理器                              │
│                                                       │
│  - 检查循环依赖                                       │
│  - 检查缺失依赖                                       │
│  - 拓扑排序（自动确定执行顺序）                        │
└─────────────────────────────────────────────────────┘
```

---

## 模块说明

### 1. 任务元数据 (`任务流程/任务元数据.py`)

定义任务的元数据结构：

- `任务参数定义`：参数名、类型、默认值、UI控件类型
- `任务状态定义`：状态名、类型、默认值
- `任务元数据`：任务的完整元数据
- `任务元数据装饰器`：自动解析任务类生成元数据（可选）

### 2. 基础任务扩展 (`任务流程/基础任务框架.py`)

扩展 `基础任务` 类，添加：

- `self.参数`：自动从数据库加载，优先使用数据库值，否则使用元数据默认值
- `self.状态`：自动从数据库加载
- `self.保存参数(**参数字典)`：保存参数到数据库
- `self.保存状态(**状态字典)`：保存状态到数据库

### 3. 数据库扩展 (`数据库/任务数据库.py`)

新增两张表：

```sql
-- 任务参数表
CREATE TABLE 任务参数 (
    机器人标志 TEXT NOT NULL,
    任务类名 TEXT NOT NULL,
    参数名 TEXT NOT NULL,
    参数值 TEXT NOT NULL,  -- JSON格式
    更新时间 REAL,
    PRIMARY KEY (机器人标志, 任务类名, 参数名)
)

-- 任务状态表
CREATE TABLE 任务状态 (
    机器人标志 TEXT NOT NULL,
    任务类名 TEXT NOT NULL,
    状态键 TEXT NOT NULL,
    状态值 TEXT NOT NULL,  -- JSON格式
    更新时间 REAL,
    PRIMARY KEY (机器人标志, 任务类名, 状态键)
)
```

新增方法：

- `保存任务参数(机器人标志, 任务类名, 参数字典)`
- `获取任务参数(机器人标志, 任务类名)`
- `保存任务状态(机器人标志, 任务类名, 状态字典)`
- `获取任务状态(机器人标志, 任务类名)`

### 4. UI自动生成器 (`界面/任务配置UI生成器.py`)

根据元数据自动生成Tkinter配置界面：

- 复选框（bool类型）
- 输入框（int/float/str类型）
- 下拉框（有候选项）
- 滑块（int/float + 最小值/最大值）

### 5. 任务依赖管理器 (`任务流程/任务依赖管理器.py`)

管理任务依赖关系：

- `检查循环依赖()`：检测任务间的循环依赖
- `检查缺失依赖()`：检测引用了不存在的任务
- `拓扑排序(任务列表)`：返回可执行的任务顺序
- `获取任务依赖树(任务名)`：可视化依赖关系

---

## 使用指南

### 1. 定义任务（手动构建元数据）

```python
from 任务流程.基础任务框架 import 基础任务
from 任务流程.任务元数据 import 任务元数据, 任务参数定义, 任务状态定义, UI控件类型

class 升级城墙(基础任务):
    """升级城墙任务"""

    元数据 = 任务元数据(
        任务名称="升级城墙",
        显示名称="升级城墙",
        描述="自动升级所有可升级的城墙",
        参数列表=[
            任务参数定义(
                参数名="开启刷墙",
                参数类型=bool,
                默认值=False,
                描述="是否启用自动刷墙功能",
                UI控件=UI控件类型.复选框
            ),
            任务参数定义(
                参数名="刷墙起始金币",
                参数类型=int,
                默认值=100000,
                描述="金币低于此值时不刷墙",
                UI控件=UI控件类型.输入框,
                最小值=0,
                最大值=10000000
            ),
        ],
        状态列表=[
            任务状态定义(
                状态名="已升级城墙数量",
                状态类型=int,
                默认值=0
            ),
            任务状态定义(
                状态名="上次升级时间",
                状态类型=float,
                默认值=0.0
            ),
        ],
        前置任务=["更新主世界账号资源状态"],
    )

    def 执行(self) -> bool:
        try:
            # 1. 访问参数
            if not self.参数.开启刷墙:
                self.上下文.置脚本状态("刷墙功能未启用")
                return True

            # 2. 访问状态
            self.上下文.置脚本状态(f"已升级 {self.状态.已升级城墙数量} 个城墙")

            # 3. 执行业务逻辑
            # ...

            # 4. 保存状态
            import time
            self.保存状态(
                已升级城墙数量=self.状态.已升级城墙数量 + 1,
                上次升级时间=time.time()
            )

            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

### 2. 定义任务（使用装饰器）

```python
# 注意：装饰器功能待完善，目前推荐手动方式

from 任务流程.任务元数据 import 任务元数据装饰器

@任务元数据装饰器(
    显示名称="升级英雄",
    描述="自动升级选定的英雄",
    前置任务=["更新主世界账号资源状态"]
)
class 升级英雄(基础任务):
    # 参数定义（通过类属性）
    欲升级的英雄: list = ["弓箭女皇", "亡灵王子"]
    是否等待升级完成: bool = False

    # 状态定义（通过内部类）
    class 状态:
        当前升级的英雄: str = ""
        升级开始时间: float = 0.0

    def 执行(self):
        # 使用 self.参数.欲升级的英雄
        # 使用 self.状态.当前升级的英雄
        pass
```

### 3. 自动生成UI

```python
import tkinter as tk
from 界面.任务配置UI生成器 import 任务配置界面生成器
from 数据库.任务数据库 import 任务数据库

# 创建窗口
根窗口 = tk.Tk()
数据库 = 任务数据库()

# 创建生成器
生成器 = 任务配置界面生成器(根窗口, 数据库, "机器人001")

# 生成配置界面（支持多个任务）
生成器.生成批量配置界面([升级城墙, 升级英雄, ...])

根窗口.mainloop()
```

### 4. 任务依赖管理

```python
from 任务流程.任务依赖管理器 import 任务依赖管理器

# 创建管理器
管理器 = 任务依赖管理器([任务A, 任务B, 任务C, ...])

# 检查循环依赖
循环依赖 = 管理器.检查循环依赖()
if 循环依赖:
    print(f"发现循环依赖: {循环依赖}")

# 自动排序任务
执行顺序 = 管理器.拓扑排序(["任务C"])  # 自动包含依赖的任务
# 结果：["任务A", "任务B", "任务C"]

# 可视化依赖树
print(管理器.获取任务依赖树("任务C"))
```

### 5. 在主流程中使用

```python
# 线程/自动化机器人.py

from 任务流程.任务依赖管理器 import 任务依赖管理器
from 任务流程.升级城墙 import 升级城墙
from 任务流程.更新主世界账号资源状态 import 更新主世界账号资源状态

# 定义任务列表
所有任务 = [更新主世界账号资源状态, 升级城墙, ...]

# 创建依赖管理器
管理器 = 任务依赖管理器(所有任务)

# 获取执行顺序
欲执行的任务 = ["升级城墙"]  # 用户选择的任务
执行顺序 = 管理器.拓扑排序(欲执行的任务)

# 按顺序执行
for 任务名 in 执行顺序:
    任务类 = 管理器.任务字典[任务名]
    任务实例 = 任务类(上下文)
    是否继续 = 任务实例.执行()
    if not 是否继续:
        break
```

---

## 优势总结

### 解耦优势

| 之前 | 现在 |
|------|------|
| 添加参数 → 修改数据库 + 修改UI + 修改任务代码 | 添加参数 → 只修改任务元数据 |
| 存储状态 → 设计表结构 + 写SQL | 存储状态 → 调用 `self.保存状态()` |
| 任务依赖 → 手动排序 + 注释说明 | 任务依赖 → 声明元数据 + 自动检查 |

### 技术优势

1. **声明式编程**：元数据即文档
2. **类型安全**：参数有明确类型定义
3. **自动验证**：依赖管理器自动检查循环依赖和缺失依赖
4. **快速开发**：UI自动生成
5. **易于维护**：修改只涉及元数据

---

## 迁移指南

### 如何迁移现有任务

1. **添加元数据**：为任务类添加 `元数据` 属性
2. **迁移参数**：
   - 将 `机器人设置` 中的任务专属参数移到任务元数据
   - 在 `执行()` 中用 `self.参数.xxx` 替代 `上下文.设置.xxx`
3. **迁移状态**：
   - 识别任务中需要持久化的变量
   - 定义为状态字段
   - 用 `self.保存状态()` 替代直接操作数据库
4. **声明依赖**：
   - 识别任务的前置任务
   - 在元数据中声明

### 示例：迁移 `升级城墙.py`

**迁移前**：
```python
class 升级城墙(基础任务):
    def 执行(self) -> bool:
        设置 = self.上下文.设置
        if not 设置.开启刷墙:
            return True
        # ...
```

**迁移后**：
```python
class 升级城墙(基础任务):
    元数据 = 任务元数据(
        任务名称="升级城墙",
        显示名称="升级城墙",
        参数列表=[
            任务参数定义("开启刷墙", bool, False, "是否启用刷墙"),
        ],
        前置任务=["更新主世界账号资源状态"]
    )

    def 执行(self) -> bool:
        if not self.参数.开启刷墙:
            return True
        # ...
```

---

## 常见问题

### Q1: 如果任务不需要参数或状态怎么办？

**A**: 不定义即可，`参数列表` 和 `状态列表` 都是可选的。框架会自动创建空对象。

### Q2: 参数存储在哪里？和 `机器人设置` 有什么区别？

**A**:
- `机器人设置`：全局配置，所有任务共享（如模拟器索引、服务器）
- `任务参数`：任务专属配置，只对该任务有效

### Q3: 状态和运行时状态有什么区别？

**A**:
- `任务状态`：任务自身的状态（如"已升级城墙数量"）
- `运行时状态`：机器人的全局状态（如"家乡资源"），供所有任务读取

### Q4: 如何在任务间共享数据？

**A**: 使用 `运行时状态` 表：
```python
# 任务A保存
self.数据库.更新状态(self.机器人标志, "共享数据", {"键": "值"})

# 任务B读取
状态 = self.数据库.获取最新完整状态(self.机器人标志)
数据 = 状态.状态数据["共享数据"]["键"]
```

---

## 未来扩展

1. **参数校验**：支持参数范围校验、正则表达式等
2. **条件依赖**：支持"如果参数X=Y，则依赖任务Z"
3. **任务调度器**：支持定时执行、重试策略
4. **Web UI**：自动生成Web配置界面
5. **任务导出**：支持导出任务配置为JSON/YAML

---

## 相关文件

| 文件 | 说明 |
|------|------|
| `任务流程/任务元数据.py` | 元数据定义 |
| `任务流程/基础任务框架.py` | 基础任务扩展 |
| `数据库/任务数据库.py` | 数据库扩展 |
| `界面/任务配置UI生成器.py` | UI自动生成器 |
| `任务流程/任务依赖管理器.py` | 依赖管理器 |
| `任务流程/示例_使用元数据的任务.py` | 完整示例 |

---

## 联系与反馈

如有问题或建议，请在GitHub提交Issue。
