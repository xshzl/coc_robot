# 任务开发文档

## 目录

1. [项目结构概览](#1-项目结构概览)
2. [核心数据结构](#2-核心数据结构)
3. [任务基类体系](#3-任务基类体系)
4. [检测引擎使用指南](#4-检测引擎使用指南)
5. [任务开发步骤](#5-任务开发步骤)
6. [常用工具函数](#6-常用工具函数)
7. [任务执行流程示例](#7-任务执行流程示例)
8. [最佳实践与注意事项](#8-最佳实践与注意事项)
9. [设计原则](#9-设计原则)

---

## 1. 项目结构概览

### 1.1 任务流程目录结构

```
任务流程/
├── __init__.py                          # 核心数据结构和基础任务框架
├── 基础任务框架.py                      # 任务基类和上下文定义
├── 启动模拟器.py                        # 模拟器启动任务
├── 检测游戏登录状态.py                  # 游戏登录状态检测
├── 检查图像.py                          # 图像检查
├── 更新主世界账号资源状态.py            # 资源识别与更新
├── 升级城墙.py                          # 城墙升级主任务
│
├── 世界跳转/                            # 主世界和夜世界的切换
│   ├── 进入世界基类.py                  # 世界跳转基类
│   ├── 到主世界任务.py
│   └── 到夜世界任务.py
│
├── 主世界打鱼/                          # 主世界搜索敌人和进攻
│   ├── __init__.py
│   ├── 打开进攻页面.py
│   ├── 搜索敌人.py
│   ├── 进攻.py
│   ├── 进攻坐标逻辑计算.py              # 进攻坐标计算（核心算法）
│   └── 等待战斗结束并回营.py
│
├── 天鹰火炮成就/                        # 天鹰火炮成就刷取
│   ├── __init__.py                      # 任务链入口（刷天鹰火炮任务）
│   ├── 天鹰火炮检测器.py                # YOLO v8 ONNX 检测器
│   ├── 天鹰火炮进攻任务.py              # 搜索+检测+攻击逻辑
│   ├── 等待战斗结束并回营.py            # 放弃战斗回营
│   └── 模型/
│       └── best.pt                      # YOLO模型（首次运行自动转ONNX）
│
├── 建筑升级/                            # 建筑升级模块
│   ├── __init__.py
│   ├── 寻找建筑.py                      # 寻找可升级建筑
│   ├── 升级英雄.py                      # 英雄升级
│   └── 更新工人状态.py
│
└── 夜世界/                              # 夜世界相关任务
    ├── 更新夜世界账号资源状态.py
    ├── 收集圣水车.py
    └── 夜世界打鱼/
        ├── __init__.py
        ├── 夜世界基础任务类.py          # 基础任务的别名（向后兼容）
        ├── 打开进攻页面任务.py
        ├── 下兵.py
        ├── 等待进入战斗.py
        └── 等待回营或第二场战斗.py
```

---

## 2. 核心数据结构

### 2.1 任务上下文（TaskContext）

任务上下文是所有任务执行时的核心数据载体，包含了任务执行所需的所有依赖。

**位置**: `任务流程/基础任务框架.py`

```python
@dataclass
class 任务上下文:
    机器人标志: str                        # 机器人唯一标识
    数据库: 任务数据库                     # 数据库连接
    消息队列: queue.Queue                  # 线程间通信
    继续事件: threading.Event              # 暂停控制
    停止事件: threading.Event              # 停止控制
    op: op类                              # 屏幕图像获取
    雷电模拟器: 雷电模拟器操作类          # 模拟器控制
    键盘: 键盘控制器                       # 键盘输入
    鼠标: 鼠标控制器                       # 鼠标输入
    置脚本状态: Callable                  # 状态回调函数
```

### 2.2 上下文关键方法

| 方法 | 参数 | 说明 |
|------|------|------|
| `脚本延时(毫秒数)` | `int` | 线程安全的延时，支持暂停/停止事件 |
| `点击(x, y, 延时, 是否精确点击)` | `int, int, int, bool` | 模拟人类点击，自动加随机偏移 |
| `滑动屏幕(起点坐标, 终点坐标)` | `Tuple, Tuple` | 使用贝塞尔曲线模拟滑动 |
| `置脚本状态(msg, 超时时间, 级别)` | `str, float, str` | 记录日志（级别可选：正常/警告/错误） |
| `发送重启请求(原因)` | `str` | 请求脚本重启 |
| `处理异常(任务名, 异常, 是否重启游戏, 是否重启机器人)` | `str, Exception, bool, bool` | 统一异常处理入口 |
| `设置` | 属性 | 获取当前机器人的配置（返回 `机器人设置` 对象） |

### 2.3 上下文使用示例

```python
def 执行(self) -> bool:
    上下文 = self.上下文
    # 设置当前状态（记录日志到数据库和UI）
    上下文.置脚本状态("正在执行任务...")

    # 延时等待
    上下文.脚本延时(1000)  # 等待1秒

    # 点击操作
    上下文.点击(100, 200, 500)  # 点击坐标(100,200)，延时500ms

    # 精确点击（不加随机偏移）
    上下文.点击(100, 200, 500, 是否精确点击=True)

    # 滑动操作
    上下文.滑动屏幕((100, 200), (300, 400))

    # 获取截图
    屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

    # 获取配置（通过上下文的 设置 属性）
    settings = 上下文.设置
    最小资源 = settings.欲进攻的最小资源

    return True
```

---

## 3. 任务基类体系

### 3.1 统一基础任务基类

项目使用统一的 `基础任务` 基类，已预初始化所有常用检测引擎。`夜世界基础任务` 是 `基础任务` 的别名，保持向后兼容。

**位置**: `任务流程/基础任务框架.py`

```python
from abc import ABC, abstractmethod

class 基础任务(ABC):
    """游戏任务基类 - 统一的任务基类，自动初始化常用工具"""

    def __init__(self, 上下文: '任务上下文'):
        self.上下文 = 上下文
        # 自动初始化常用工具
        self.模板识别 = 模板匹配引擎()
        self.ocr引擎 = 安全OCR引擎()
        self.检测器 = 线程安全YOLO检测器()
        # 便捷属性
        self.数据库 = 上下文.数据库
        self.机器人标志 = 上下文.机器人标志

    @abstractmethod
    def 执行(self) -> bool:
        """
        执行任务的主方法（无需传入上下文，通过 self.上下文 访问）

        Returns:
            bool: True 继续下一个任务，False 终止流程
        """
        pass

    def 异常处理(self, 异常: Exception, 是否重启游戏=True, 是否重启机器人=True):
        """统一异常处理 - 委托给上下文处理"""
        self.上下文.处理异常(self.__class__.__name__, 异常, 是否重启游戏, 是否重启机器人)

    def 是否出现图片(self, 模板路径: str, 区域=(0, 0, 800, 600),
                  相似度阈值=0.9) -> Tuple[bool, Tuple[int, int]]:
        """
        执行模板匹配

        Args:
            模板路径: 模板图片路径，支持 | 分隔多个模板
            区域: 搜索区域 (x1, y1, x2, y2)
            相似度阈值: 匹配阈值，默认0.9

        Returns:
            Tuple[bool, Tuple[int, int]]: (是否匹配, 匹配坐标)
        """
        pass

    # 兼容旧方法名
    已出现图片 = 是否出现图片

    def 执行OCR识别(self, 区域=(0, 0, 800, 600)) -> list:
        """执行屏幕OCR识别"""
        pass
```

### 3.2 基类提供的便捷属性

| 属性 | 类型 | 说明 |
|------|------|------|
| `self.上下文` | `任务上下文` | 任务执行上下文，包含所有依赖 |
| `self.模板识别` | `模板匹配引擎` | 模板匹配引擎实例 |
| `self.ocr引擎` | `安全OCR引擎` | OCR识别引擎实例 |
| `self.检测器` | `线程安全YOLO检测器` | YOLO检测器实例 |
| `self.数据库` | `任务数据库` | 数据库连接 |
| `self.机器人标志` | `str` | 当前机器人标识 |

### 3.4 夜世界基础任务（别名）

**位置**: `任务流程/夜世界/夜世界打鱼/夜世界基础任务类.py`

`夜世界基础任务` 现在是 `基础任务` 的别名，继承自哪个基类效果完全相同：

```python
# 夜世界基础任务现在是基础任务的别名
from 任务流程.基础任务框架 import 基础任务
夜世界基础任务 = 基础任务
```

### 3.5 基类选择指南

| 场景 | 推荐基类 | 说明 |
|------|---------|------|
| 所有游戏任务 | `基础任务` | 已预初始化所有检测引擎，推荐使用 |
| 夜世界任务 | `夜世界基础任务` | 等同于 `基础任务`，保持向后兼容 |
| 世界跳转任务 | `进入世界任务基类` | 专用于世界切换，继承自 `基础任务` |

---

## 4. 检测引擎使用指南

### 4.1 模板匹配引擎

用于UI按钮、固定图标的识别。

```python
from 任务流程.基础任务框架 import 基础任务

class 我的任务(基础任务):
    # 无需手动初始化，基类已自动初始化 self.模板识别

    def 执行(self) -> bool:
        上下文 = self.上下文
        # 获取屏幕截图
        屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

        # 单模板匹配（模板路径不包含 "模板/" 前缀）
        是否匹配, (x, y), 相似度 = self.模板识别.执行匹配(
            屏幕图像,
            "按钮.bmp",
            相似度阈值=0.9
        )

        # 多模板匹配（任意一个匹配即可）
        是否匹配, (x, y), _ = self.模板识别.执行匹配(
            屏幕图像,
            "模板1.bmp|模板2.bmp|模板3.bmp",  # 用 | 分隔
            相似度阈值=0.85
        )

        if 是否匹配:
            上下文.点击(x, y, 500)

        # 也可以使用基类封装的便捷方法
        是否匹配, (x, y) = self.是否出现图片("按钮.bmp", (0, 0, 800, 600))

        return True
```

### 4.2 OCR识别引擎

用于文字识别，如资源数值、建筑名称等。

```python
class 我的任务(基础任务):
    # 无需手动初始化，基类已自动初始化 self.ocr引擎

    def 执行(self) -> bool:
        上下文 = self.上下文
        # 获取指定区域截图
        区域图像 = 上下文.op.获取屏幕图像cv(14, 67, 151, 146)

        # 执行OCR识别
        result, _ = self.ocr引擎(区域图像)

        # result 格式: [[[坐标列表], 文本], ...]
        for item in result:
            坐标 = item[0]
            文本 = str(item[1])
            print(f"识别到: {文本}")

        # 也可以使用基类封装的便捷方法
        ocr结果 = self.执行OCR识别((14, 67, 151, 146))

        return True

    def 文本转数值(self, 文本: str) -> int:
        """清理OCR识别的数字文本"""
        import re
        cleaned = re.sub(r'[^\d]', '', 文本)
        return int(cleaned) if cleaned else 0
```

### 4.3 YOLO检测引擎

用于游戏对象检测，如建筑、兵种等。

```python
class 我的任务(基础任务):
    # 无需手动初始化，基类已自动初始化 self.检测器

    def 执行(self) -> bool:
        上下文 = self.上下文
        # 获取全屏截图
        屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

        # 执行YOLO检测
        检测结果列表 = self.检测器.检测(屏幕图像)

        # 遍历检测结果
        for 结果 in 检测结果列表:
            类别名称 = 结果['类别名称']
            裁剪坐标 = 结果['裁剪坐标']  # [x1, y1, x2, y2]
            置信度 = 结果['置信度']

            # 筛选特定类别
            if 类别名称 in ['金矿', '圣水采集器']:
                中心x = (裁剪坐标[0] + 裁剪坐标[2]) // 2
                中心y = (裁剪坐标[1] + 裁剪坐标[3]) // 2
                print(f"发现 {类别名称} 在 ({中心x}, {中心y})")

        return True
```

---

## 5. 任务开发步骤

### 5.1 创建新任务的标准流程

#### 第一步：创建任务文件

```python
# 任务流程/我的新任务.py

from 任务流程.基础任务框架 import 基础任务, 任务上下文

class 我的新任务(基础任务):
    """
    任务描述：这个任务做什么
    注意：基类已自动初始化 self.模板识别、self.ocr引擎、self.检测器
          以及 self.数据库、self.机器人标志 等便捷属性
    """

    # 如果不需要额外初始化，可以省略 __init__

    def 执行(self) -> bool:
        """
        任务主执行方法（通过 self.上下文 访问上下文）

        Returns:
            bool: True 继续下一个任务，False 终止流程
        """
        try:
            上下文 = self.上下文
            # 1. 设置状态
            上下文.置脚本状态("正在执行我的新任务")

            # 2. 执行业务逻辑
            # ... 你的代码 ...

            # 3. 返回结果
            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

#### 第二步：实现业务逻辑

```python
def 执行(self) -> bool:
    try:
        上下文 = self.上下文
        上下文.置脚本状态("开始执行任务")

        # 等待界面加载
        上下文.脚本延时(1000)

        # 检测目标按钮
        屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
        是否匹配, (x, y), _ = self.模板识别.执行匹配(
            屏幕图像,
            "目标按钮.bmp",
            相似度阈值=0.9
        )

        if not 是否匹配:
            上下文.置脚本状态("[警告] 未找到目标按钮")
            return False

        # 点击按钮
        上下文.点击(x, y, 500)

        # 等待结果
        上下文.脚本延时(2000)

        上下文.置脚本状态("任务执行完成")
        return True

    except Exception as e:
        self.异常处理(e)
        return False
```

#### 第三步：将任务集成到主流程

实际项目中，任务是在 `线程/自动化机器人.py` 的 `_任务流程()` 方法中直接实例化并执行的：

```python
# 在 线程/自动化机器人.py 中
from 任务流程.我的新任务 import 我的新任务

def _任务流程(self):
    # 创建任务上下文
    上下文 = 任务上下文(
        机器人标志=self.机器人标志,
        数据库=self.数据库,
        # ... 其他参数
    )

    # 直接实例化并执行任务（构造时传入上下文，执行时无需再传）
    启动模拟器任务(上下文).执行()
    检测登录.执行()

    # 根据配置决定执行哪些任务
    if self.设置.是否刷主世界:
        到主世界任务(上下文).执行()

        while True:  # 主循环
            我的新任务(上下文).执行()  # 添加新任务
            建筑升级任务(上下文).执行()
            # ... 其他任务

            # 根据条件判断是否继续
            if not 继续条件:
                break
```

**注意**：任务不是放在列表中遍历执行，而是根据业务逻辑直接调用 `任务类(上下文).执行()`。

### 5.2 简单任务示例

```python
class 打开进攻页面任务(基础任务):
    """打开游戏进攻页面"""

    def 执行(self) -> bool:
        上下文 = self.上下文
        上下文.置脚本状态("开始进攻,打开进攻页面")
        上下文.点击(62, 546, 1000)   # 点击进攻按钮
        上下文.点击(156, 426, 500)   # 点击确认
        上下文.点击(673, 460, 500)   # 点击开始
        return True
```

### 5.3 复杂任务示例（循环搜索模式）

```python
class 搜索敌人任务(基础任务):
    """搜索符合条件的敌人"""

    # 无需手动初始化检测引擎，基类已自动初始化

    def 执行(self) -> bool:
        上下文 = self.上下文
        搜索次数 = 0
        最大搜索次数 = 100

        while 搜索次数 < 最大搜索次数:
            搜索次数 += 1
            上下文.置脚本状态(f"搜索敌人中... ({搜索次数}/{最大搜索次数})")

            # 执行单次搜索
            if self.单次搜索():
                return True

            # 点击下一个
            上下文.点击(710, 535, 800)

        上下文.记录警告("达到最大搜索次数，未找到合适敌人")
        return False

    def 单次搜索(self) -> bool:
        上下文 = self.上下文
        # 识别资源
        资源 = self.识别当前资源()

        # 获取配置（settings 是 dataclass 对象）
        settings = self.数据库.获取机器人设置(self.机器人标志)
        最小资源 = settings.欲进攻的最小资源

        # 检查是否符合条件
        if 资源['总资源'] >= 最小资源:
            上下文.置脚本状态(f"找到目标: 总资源 {资源['总资源']}")
            return True

        return False

    def 识别当前资源(self) -> dict:
        屏幕图像 = self.上下文.op.获取屏幕图像cv(14, 67, 151, 146)
        result, _ = self.ocr引擎(屏幕图像)

        金币 = self.文本转数值(str(result[0][1])) if len(result) > 0 else 0
        圣水 = self.文本转数值(str(result[1][1])) if len(result) > 1 else 0
        黑油 = self.文本转数值(str(result[2][1])) if len(result) > 2 else 0

        return {
            "金币": 金币,
            "圣水": 圣水,
            "黑油": 黑油,
            "总资源": 金币 + 圣水
        }

    def 文本转数值(self, 文本: str) -> int:
        import re
        cleaned = re.sub(r'[^\d]', '', 文本)
        return int(cleaned) if cleaned else 0
```

---

## 6. 常用工具函数

### 6.1 颜色检测（HSV模式）

检测图像中是否包含指定颜色，用于判断按钮状态、资源不足等。

```python
import cv2
import numpy as np

@staticmethod
def 是否包含指定颜色_HSV(图像: np.ndarray, 目标RGB: tuple,
                         色差H=10, 色差S=100, 色差V=100,
                         最少像素数=1000) -> bool:
    """
    检测图像中是否包含指定颜色

    Args:
        图像: OpenCV格式图像 (BGR)
        目标RGB: 目标颜色RGB值
        色差H/S/V: 各通道容差
        最少像素数: 最少匹配像素数

    Returns:
        bool: 是否包含指定颜色
    """
    # RGB转HSV
    目标BGR = (目标RGB[2], 目标RGB[1], 目标RGB[0])
    目标HSV = cv2.cvtColor(np.uint8([[目标BGR]]), cv2.COLOR_BGR2HSV)[0][0]

    # 创建掩码
    hsv图像 = cv2.cvtColor(图像, cv2.COLOR_BGR2HSV)
    下界 = np.array([目标HSV[0] - 色差H, 目标HSV[1] - 色差S, 目标HSV[2] - 色差V])
    上界 = np.array([目标HSV[0] + 色差H, 目标HSV[1] + 色差S, 目标HSV[2] + 色差V])

    掩码 = cv2.inRange(hsv图像, 下界, 上界)
    匹配像素数 = cv2.countNonZero(掩码)

    return 匹配像素数 >= 最少像素数

# 使用示例：检查资源不足（粉红色）
区域图像 = 上下文.op.获取屏幕图像cv(100, 200, 300, 400)
资源不足 = 是否包含指定颜色_HSV(区域图像, (250, 135, 124))
```

### 6.2 白框检测（兵种选中状态）

```python
@staticmethod
def 检测白色矩形框(CV图像, 最小面积=1000, 阈值=200):
    """
    检测兵种UI上的白框，判断是否已选中

    Returns:
        Tuple[bool, list, np.ndarray]: (是否检测到, 框坐标列表, 标记图像)
    """
    灰度图 = cv2.cvtColor(CV图像, cv2.COLOR_BGR2GRAY)
    _, 二值图 = cv2.threshold(灰度图, 阈值, 255, cv2.THRESH_BINARY)

    轮廓, _ = cv2.findContours(二值图, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    框列表 = []
    for 轮廓项 in 轮廓:
        面积 = cv2.contourArea(轮廓项)
        if 面积 >= 最小面积:
            x, y, w, h = cv2.boundingRect(轮廓项)
            框列表.append((x, y, w, h))

    return len(框列表) > 0, 框列表, CV图像
```

### 6.3 灰色图片判断（兵种用完检测）

```python
@staticmethod
def 是否为灰色图片(CV图像, 偏差阈值=10, 灰色比例阈值=0.9) -> bool:
    """
    判断图片是否为灰色，用于判断兵种是否已下完

    Args:
        CV图像: OpenCV格式图像
        偏差阈值: RGB通道间差值阈值
        灰色比例阈值: 灰色像素占比阈值

    Returns:
        bool: 是否为灰色图片
    """
    b, g, r = cv2.split(CV图像)

    # 计算RGB通道间差值
    diff_rg = np.abs(r.astype(int) - g.astype(int))
    diff_rb = np.abs(r.astype(int) - b.astype(int))
    diff_gb = np.abs(g.astype(int) - b.astype(int))

    # 判断灰色像素
    灰色掩码 = (diff_rg < 偏差阈值) & (diff_rb < 偏差阈值) & (diff_gb < 偏差阈值)
    灰色比例 = np.sum(灰色掩码) / 灰色掩码.size

    return 灰色比例 >= 灰色比例阈值
```

### 6.4 贝塞尔曲线生成（模拟人类滑动）

```python
def 生成贝塞尔轨迹(起点, 控制点1, 控制点2, 终点, 步数=20) -> list:
    """
    生成贝塞尔曲线路径，用于模拟人类滑动操作

    Args:
        起点: (x, y)
        控制点1: (x, y)
        控制点2: (x, y)
        终点: (x, y)
        步数: 轨迹点数量

    Returns:
        list: 轨迹点列表 [(x, y), ...]
    """
    轨迹 = []
    for i in range(步数 + 1):
        t = i / 步数
        x = (1-t)**3 * 起点[0] + 3*(1-t)**2*t * 控制点1[0] + \
            3*(1-t)*t**2 * 控制点2[0] + t**3 * 终点[0]
        y = (1-t)**3 * 起点[1] + 3*(1-t)**2*t * 控制点1[1] + \
            3*(1-t)*t**2 * 控制点2[1] + t**3 * 终点[1]
        轨迹.append((int(x), int(y)))
    return 轨迹
```

---

## 7. 任务执行流程示例

### 7.1 主世界进攻流程

```
打开进攻页面任务
      ↓
搜索目标敌人任务（循环）
  ├─ 等待"下一个"按钮
  ├─ OCR识别资源
  ├─ YOLO检测资源建筑
  ├─ 判断是否符合条件
  └─ 符合则返回True
      ↓
进攻任务
  ├─ YOLO检测所有资源建筑
  ├─ 选中兵种（模板匹配+白框检测）
  ├─ 检查兵种数量（灰色判断）
  ├─ 计算下兵坐标并点击
  └─ 返回True
      ↓
等待战斗结束并回营任务
  ├─ 循环检测"回营"按钮
  ├─ 点击回营
  └─ 返回True
```

### 7.2 建筑升级流程

```
城墙升级任务
      ↓
检查功能是否开启
      ↓
循环：while 已够资源升级()
  ├─ 更新家乡资源状态
  ├─ 判断资源是否足够
  └─ 执行升级操作
      ├─ 进入城墙界面
      ├─ OCR识别可升级建筑
      ├─ 颜色检测资源是否足够
      └─ 点击升级
```

### 7.3 状态机模式（登录检测）

```python
class 检测游戏登录状态任务(基础任务):
    def 执行(self) -> bool:
        上下文 = self.上下文
        超时时间 = 180  # 秒
        开始时间 = time.time()

        while time.time() - 开始时间 < 超时时间:
            屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

            # 检测各种界面状态
            if self.检测重新载入(屏幕图像):
                self.处理重新载入()
                continue

            if self.检测顶号弹窗(屏幕图像):
                self.处理顶号()
                continue

            if self.检测开宝箱界面(屏幕图像):
                self.处理开宝箱()
                continue

            if self.检测已登录(屏幕图像):
                return True

            上下文.脚本延时(1000)

        return False
```

---

## 8. 最佳实践与注意事项

### 8.1 代码规范

1. **任务命名**: 使用中文命名，清晰表达任务功能
2. **方法返回值**: `执行()` 方法必须返回 `bool` 类型
3. **异常处理**: 使用 try-except 包裹业务逻辑
4. **状态更新**: 关键节点调用 `上下文.置脚本状态()`

### 8.2 性能优化

```python
# 推荐：只获取需要的区域
区域图像 = 上下文.op.获取屏幕图像cv(100, 200, 300, 400)

# 不推荐：获取全屏再裁剪
全屏图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
区域图像 = 全屏图像[200:400, 100:300]
```

### 8.3 容错设计

```python
# 推荐：添加重试机制
最大重试次数 = 3
for 重试 in range(最大重试次数):
    if self.执行核心逻辑(上下文):
        return True
    上下文.脚本延时(1000)
return False

# 推荐：添加超时检测
开始时间 = time.time()
超时秒数 = 60
while time.time() - 开始时间 < 超时秒数:
    if self.检测完成(上下文):
        return True
    上下文.脚本延时(500)
return False
```

### 8.4 人类行为模拟

```python
# 推荐：使用随机延时
import random

def 随机延时(self, 基础毫秒: int, 浮动比例=0.2):
    浮动 = int(基础毫秒 * 浮动比例)
    实际延时 = random.randint(基础毫秒 - 浮动, 基础毫秒 + 浮动)
    self.上下文.脚本延时(实际延时)

# 点击时不使用精确点击，自动添加随机偏移
上下文.点击(100, 200, 500, 是否精确点击=False)  # 默认False
```

### 8.5 数据库配置读取

```python
def 执行(self) -> bool:
    # 通过便捷属性访问（基类已初始化 self.数据库 和 self.机器人标志）
    settings = self.数据库.获取机器人设置(self.机器人标志)

    # 读取配置项（使用属性访问，不是字典的 .get() 方法）
    最小资源 = settings.欲进攻的最小资源
    边缘比例 = settings.欲进攻资源建筑靠近地图边缘最小比例
    开启刷墙 = settings.开启刷墙

    # 根据配置执行逻辑
    if 开启刷墙:
        self.执行刷墙逻辑()

    return True
```

### 8.6 常见错误避免

| 错误 | 正确做法 |
|------|----------|
| 忘记返回值 | `执行()` 方法必须返回 `True` 或 `False` |
| 硬编码配置 | 使用 `数据库.获取机器人设置()` 读取配置 |
| 无限循环 | 添加超时检测或最大重试次数 |
| 忽略异常 | 使用 try-except 并记录日志 |
| 阻塞主线程 | 使用 `脚本延时()` 而非 `time.sleep()` |

---

## 9. 设计原则

### 9.1 架构设计原则

#### 单一职责原则
- 每个任务类只负责一个具体功能
- 检测引擎独立封装，与业务逻辑解耦
- 上下文对象负责资源管理，任务对象负责业务逻辑

#### 依赖注入原则
- 任务通过 `任务上下文` 获取所有依赖
- 避免在任务内部直接创建依赖对象
- 便于测试和替换实现

#### 组合优于继承
- 任务类通过组合使用检测引擎
- 基类仅提供通用工具和接口定义
- 避免深层继承导致的复杂性

### 9.2 任务开发原则

#### 幂等性设计
```python
# 推荐：检查当前状态再执行
def 执行(self) -> bool:
    if self.已在目标状态():
        return True  # 已经完成，直接返回
    return self.执行核心逻辑()
```

#### 防御性编程
```python
# 推荐：添加边界检查和超时保护
最大尝试次数 = 100
for i in range(最大尝试次数):
    if self.检测完成():
        return True
    上下文.脚本延时(500)

raise RuntimeError(f"超时：循环 {最大尝试次数} 次未完成")
```

#### 日志规范
```python
# 关键节点记录日志
上下文.置脚本状态("开始执行任务")
上下文.置脚本状态(f"当前进度: {当前}/{总数}")
上下文.置脚本状态("[警告] 资源不足，跳过升级")
上下文.置脚本状态("[错误] 检测失败")
```

### 9.3 检测引擎选择原则

| 场景 | 推荐引擎 | 原因 |
|------|---------|------|
| UI按钮、固定图标 | 模板匹配 | 速度快，精度高 |
| 文字、数字 | OCR | 专门处理文字识别 |
| 游戏对象（建筑、兵种） | YOLO | 支持多目标检测，鲁棒性强 |
| 颜色状态判断 | HSV颜色检测 | 判断按钮状态、资源充足等 |

### 9.4 异常处理原则

```python
def 执行(self) -> bool:
    try:
        # 业务逻辑
        return True
    except 预期内异常 as e:
        # 记录日志，可能重试
        self.上下文.置脚本状态(f"[警告] {e}")
        return False
    except Exception as e:
        # 未预期异常，触发重启
        self.异常处理(e)
        return False
```

### 9.5 坐标系统约定

- 屏幕分辨率：`800 × 600`
- 坐标原点：左上角 `(0, 0)`
- 坐标范围：x: `0-800`，y: `0-600`
- 区域格式：`(x1, y1, x2, y2)` 左上角到右下角

---

## 附录：常用模板路径

```
模板/
├── 主界面/
│   ├── 进攻图标.bmp
│   ├── 宝石.bmp
│   └── 设置按钮.bmp
├── 进攻/
│   ├── 下一个按钮.bmp
│   ├── 开始战斗.bmp
│   └── 回营按钮.bmp
├── 建筑/
│   ├── 升级按钮.bmp
│   └── 确认升级.bmp
└── 登录/
    ├── 重新载入.bmp
    └── 确定按钮.bmp
```

---

*文档版本: 3.0*
*最后更新: 2026-02-06*
