import argparse
import threading
import queue
import time
from time import sleep

from 数据库.任务数据库 import 任务数据库, 机器人设置
from 模块.雷电模拟器操作类 import 雷电模拟器操作类
from 线程.自动化机器人 import 自动化机器人


# ==== 监控中心 ====
class 机器人监控中心:
    """增强型监控服务"""

    def __init__(self,日志队列=None):
        self.机器人池 = {}
        self.日志队列 = 日志队列#UI从这个队列获取日志
        self.全局消息队列 = queue.Queue()#所有在线用户共用一个消息队列和数据库
        self.数据库 = 任务数据库()
        self.运行标志 = True

        # 启动监控线程,监控每一个机器人的行为
        self.监控线程 = threading.Thread(
            target=self._监控循环,
            name="机器人监控线程",
            daemon=True
        )
        self.监控线程.start()



    def 创建机器人(self,机器人标志: str, 初始设置: 机器人设置 = None):

        if 机器人标志 in self.机器人池:
            raise ValueError(f"机器人标志[{机器人标志}],已存在")
        else:
            机器人实例 = 自动化机器人(机器人标志, self.全局消息队列, self.数据库,self.日志队列)

        if 初始设置:
            self.数据库.保存机器人设置(机器人标志, 初始设置)

        self.机器人池[机器人标志] = 机器人实例

    def 创建并启动机器人(self, 机器人标志: str, 初始设置: 机器人设置 = None):
        """创建机器人并启动"""
        self.创建机器人(机器人标志,初始设置)
        self.机器人池[机器人标志].启动()

    def _监控循环(self):
        """持续监控所有机器人的状态"""
        while self.运行标志:
            # 检查任务状态
            for 用户标识, 线程 in list(self.机器人池.items()):
                # print("监控中")
                超时状态, 原因 = 线程.检查超时()
                if  超时状态:

                    self.全局消息队列.put(f"机器人{用户标识} "+原因)
                    # 线程.请求终止()
                    # 线程.启动()
                    # 先移出机器人池再终止
                    雷电模拟器 = 雷电模拟器操作类(self.数据库.获取机器人设置(用户标识).雷电模拟器索引)
                    雷电模拟器.关闭模拟器中的应用(self.数据库.获取机器人设置(用户标识).部落冲突包名)
                    time.sleep(2)
                    雷电模拟器.打开应用(self.数据库.获取机器人设置(用户标识).部落冲突包名)
                    del self.机器人池[用户标识]
                    线程.停止("无心跳")
                    # 等待模拟器冷却
                    #time.sleep(1)  # 关键：给模拟器恢复时间
                    # 完全新建实例避免状态污染
                    self.创建并启动机器人(用户标识)
                    self.全局消息队列.put(f"机器人{用户标识} 已停止完毕,现在重启")

                # 处理消息
            self._处理消息()
            time.sleep(1)

    def _处理消息(self):
        """处理来自各个机器人的消息"""
        while not self.全局消息队列.empty():
            消息 = self.全局消息队列.get()
            if isinstance(消息, dict) and 消息.get("类型") == "重启请求":
                self.处理重启请求(消息["机器人标志"], 消息.get("原因", ""))
            else:
                print(f"[监控中心消息] {time.ctime()}: {消息}")
            self.全局消息队列.task_done()

    def 处理重启请求(self, 机器人标志: str, 重启原因: str):
        """处理机器人发起的重启请求"""
        self.全局消息队列.put(f"机器人 {机器人标志} 请求重启，原因：{重启原因}")
        if 机器人标志 in self.机器人池:
            机器人实例 = self.机器人池[机器人标志]
            # 终止当前实例
            机器人实例.停止(重启原因)
            # 等待线程结束
            if 机器人实例.主线程.is_alive():
                机器人实例.主线程.join()
            # 移除旧实例
            del self.机器人池[机器人标志]
            # 等待模拟器冷却
            time.sleep(2)
            # 创建新实例并启动
            self.创建并启动机器人(机器人标志)
            self.全局消息队列.put(f"机器人 {机器人标志} 重启完成")


# ==== 使用示例 ====
if __name__ == "__main__":
    # ==== 命令行解析 ====
    parser = argparse.ArgumentParser(description="启动指定机器人")

    parser.add_argument(
        "--机器人",
        action="append",
        nargs="+",  # 每个机器人是一组参数
        required=True,
        help="""机器人参数示例：
    --机器人 标志=模拟器0 雷电索引=1 服务器=国际服 最小资源=200000 刷墙
    标志必填，其它可选，刷墙/刷主世界/刷夜世界只要存在即开启"""
    )

    args = parser.parse_args()

    # ==== 初始化监控系统 ====
    机器人监控系统 = 机器人监控中心()


    # ==== 帮助函数：解析一组参数为字典 ====
    def 解析机器人参数(参数列表):
        参数字典 = {}
        for item in 参数列表:
            if "=" in item:
                key, value = item.split("=", 1)
                参数字典[key] = value
            else:
                # 布尔参数
                参数字典[item] = True
        return 参数字典


    # ==== 遍历每个机器人参数组并启动机器人 ====
    for 单机器人参数 in args.机器人:
        参数字典 = 解析机器人参数(单机器人参数)
        标志 = 参数字典.get("标志")
        if not 标志:
            print("每个机器人必须指定标志")
            continue

        # 获取数据库旧设置
        旧设置 = 机器人监控系统.数据库.获取机器人设置(标志)
        if not 旧设置:
            旧设置 = 机器人设置()

        # 构造最终设置，只覆盖传入参数
        最终设置 = 机器人设置(
            雷电模拟器索引=int(参数字典["雷电索引"]) if "雷电索引" in 参数字典 else 旧设置.雷电模拟器索引,
            服务器=参数字典.get("服务器", 旧设置.服务器),
            欲进攻的最小资源=int(参数字典["最小资源"]) if "最小资源" in 参数字典 else 旧设置.欲进攻的最小资源,
            开启刷墙=参数字典.get("刷墙", 旧设置.开启刷墙),
            欲进攻资源建筑靠近地图边缘最小比例=float(
                参数字典["边缘比例"]) if "边缘比例" in 参数字典 else 旧设置.欲进攻资源建筑靠近地图边缘最小比例,
            刷墙起始金币=int(参数字典["刷墙金币"]) if "刷墙金币" in 参数字典 else 旧设置.刷墙起始金币,
            刷墙起始圣水=int(参数字典["刷墙圣水"]) if "刷墙圣水" in 参数字典 else 旧设置.刷墙起始圣水,
            是否刷主世界=参数字典.get("刷主世界", 旧设置.是否刷主世界),
            是否刷夜世界=参数字典.get("刷夜世界", 旧设置.是否刷夜世界),
        )

        # 创建并启动机器人
        机器人监控系统.创建并启动机器人(标志, 最终设置)
        print(f"已启动机器人: {标志}")


    # 等待所有机器人线程结束
    try:
        短暂延迟 = 10  # 秒数，用于确认没有重启

        空闲计数 = 0
        确认次数 = 短暂延迟  # 每秒检查一次

        while True:
            活跃线程 = [
                r.主线程
                for r in 机器人监控系统.机器人池.values()
                if hasattr(r, "主线程") and r.主线程.is_alive()
            ]
            if not 活跃线程:
                空闲计数 += 1
            else:
                空闲计数 = 0  # 有线程活动，重置计数

            if 空闲计数 >= 确认次数:
                print("所有机器人线程已结束，监控系统退出")
                break

            sleep(1)
    except KeyboardInterrupt:
        print("收到退出信号，停止所有机器人")
        机器人监控系统.运行标志 = False
        for 机器人实例 in 机器人监控系统.机器人池.values():
            if hasattr(机器人实例, "主线程") and 机器人实例.主线程.is_alive():
                机器人实例.停止("手动终止")
                机器人实例.主线程.join()
        print("所有机器人已安全停止，退出程序")