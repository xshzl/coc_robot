"""
任务元数据系统使用示例

展示如何使用元数据装饰器创建解耦的任务
"""

from 任务流程.基础任务框架 import 基础任务, 任务上下文
from 任务流程.任务元数据 import (
    任务元数据,
    任务参数定义,
    任务状态定义,
    UI控件类型
)


# ===== 方式1：手动构建元数据 =====
class 升级城墙任务_手动(基础任务):
    """使用手动构建元数据的方式（更灵活，可以精确控制UI）"""

    元数据 = 任务元数据(
        任务名称="升级城墙",
        显示名称="升级城墙",
        描述="自动升级所有可升级的城墙",
        参数列表=[
            任务参数定义(
                参数名="开启刷墙",
                参数类型=bool,
                默认值=False,
                描述="是否启用自动刷墙功能",
                UI控件=UI控件类型.复选框
            ),
            任务参数定义(
                参数名="刷墙起始金币",
                参数类型=int,
                默认值=100000,
                描述="金币低于此值时不刷墙",
                UI控件=UI控件类型.输入框,
                最小值=0,
                最大值=10000000
            ),
            任务参数定义(
                参数名="刷墙起始圣水",
                参数类型=int,
                默认值=100000,
                描述="圣水低于此值时不刷墙",
                UI控件=UI控件类型.输入框,
                最小值=0,
                最大值=10000000
            ),
            任务参数定义(
                参数名="优先资源",
                参数类型=str,
                默认值="金币",
                描述="优先使用哪种资源刷墙",
                UI控件=UI控件类型.下拉框,
                候选项=["金币", "圣水", "自动选择"]
            ),
        ],
        状态列表=[
            任务状态定义(
                状态名="已升级城墙数量",
                状态类型=int,
                默认值=0,
                描述="累计已升级的城墙数量"
            ),
            任务状态定义(
                状态名="上次升级时间",
                状态类型=float,
                默认值=0.0,
                描述="上次升级城墙的时间戳"
            ),
            任务状态定义(
                状态名="上次升级位置",
                状态类型=str,
                默认值="",
                描述="上次升级的城墙位置描述"
            ),
        ],
        前置任务=["更新主世界账号资源状态"],
        互斥任务=[],
        默认启用=True
    )

    def 执行(self) -> bool:
        """执行任务"""
        try:
            上下文 = self.上下文

            # 1. 检查参数：是否启用刷墙
            if not self.参数.开启刷墙:
                上下文.置脚本状态("刷墙功能未启用，跳过")
                return True

            # 2. 获取资源状态（从其他任务保存的状态中读取）
            资源状态 = 上下文.数据库.获取最新完整状态(self.机器人标志)
            if "家乡资源" not in 资源状态.状态数据:
                上下文.置脚本状态("未找到资源状态，请先执行更新资源任务")
                return True

            金币 = 资源状态.状态数据["家乡资源"].get("金币", 0)
            圣水 = 资源状态.状态数据["家乡资源"].get("圣水", 0)

            # 3. 检查资源是否充足
            if 金币 < self.参数.刷墙起始金币 and 圣水 < self.参数.刷墙起始圣水:
                上下文.置脚本状态(f"资源不足：金币{金币}，圣水{圣水}")
                return True

            # 4. 执行刷墙逻辑（这里是示例代码）
            上下文.置脚本状态(f"开始刷墙，优先资源：{self.参数.优先资源}")

            # 模拟刷墙操作...
            # 实际代码会包含：寻找城墙、点击、升级等逻辑

            # 5. 更新状态
            import time
            self.保存状态(
                已升级城墙数量=self.状态.已升级城墙数量 + 1,
                上次升级时间=time.time(),
                上次升级位置="地图中心"
            )

            上下文.置脚本状态(f"升级城墙成功，累计：{self.状态.已升级城墙数量}次")
            return True

        except Exception as e:
            self.异常处理(e)
            return False


# ===== 方式2：使用装饰器（推荐）=====
# 注意：装饰器方式需要先实现自动解析功能，这里先展示手动方式

# from 任务流程.任务元数据 import 任务元数据装饰器
#
# @任务元数据装饰器(
#     显示名称="英雄升级",
#     描述="自动升级选定的英雄",
#     前置任务=["更新主世界账号资源状态", "更新工人状态"]
# )
# class 升级英雄任务(基础任务):
#     # 参数定义（通过类属性 + 类型注解）
#     欲升级的英雄: list = ["弓箭女皇", "亡灵王子", "飞盾战神"]
#     是否等待升级完成: bool = False
#
#     # 状态定义（通过内部类）
#     class 状态:
#         当前升级的英雄: str = ""
#         升级开始时间: float = 0.0
#         已升级次数: int = 0
#
#     def 执行(self) -> bool:
#         # 访问参数：self.参数.欲升级的英雄
#         # 访问状态：self.状态.当前升级的英雄
#         # 保存状态：self.保存状态(当前升级的英雄="弓箭女皇", 升级开始时间=time.time())
#         pass


# ===== 测试代码 =====
if __name__ == "__main__":
    from 数据库.任务数据库 import 任务数据库
    import queue
    import threading
    from 核心.op import op类
    from 模块.雷电模拟器操作类 import 雷电模拟器操作类
    from 核心.键盘操作 import 键盘控制器
    from 核心.鼠标操作 import 鼠标控制器

    # 创建测试上下文
    数据库 = 任务数据库()
    机器人标志 = "测试机器人"

    # 先保存一些资源状态用于测试
    数据库.更新状态(机器人标志, "家乡资源", {
        "金币": 500000,
        "圣水": 300000
    })

    # 创建上下文
    上下文 = 任务上下文(
        机器人标志=机器人标志,
        数据库=数据库,
        消息队列=queue.Queue(),
        继续事件=threading.Event(),
        停止事件=threading.Event(),
        op=op类(0, None),  # 模拟器索引0
        雷电模拟器=雷电模拟器操作类(0),
        键盘=键盘控制器(),
        鼠标=鼠标控制器(),
        置脚本状态=lambda msg, timeout=60, 级别="正常": print(f"[{级别}] {msg}")
    )
    上下文.继续事件.set()  # 设置为继续状态

    # 创建任务实例
    任务 = 升级城墙任务_手动(上下文)

    # 打印元数据
    print("=" * 50)
    print(f"任务名称：{任务.元数据.任务名称}")
    print(f"显示名称：{任务.元数据.显示名称}")
    print(f"描述：{任务.元数据.描述}")
    print(f"前置任务：{任务.元数据.前置任务}")
    print()

    print("参数列表：")
    for 参数 in 任务.元数据.参数列表:
        print(f"  - {参数.参数名}: {参数.参数类型.__name__} = {参数.默认值}")
        print(f"    描述: {参数.描述}")
        print(f"    UI控件: {参数.UI控件.value}")
    print()

    print("状态列表：")
    for 状态 in 任务.元数据.状态列表:
        print(f"  - {状态.状态名}: {状态.状态类型.__name__} = {状态.默认值}")
        print(f"    描述: {状态.描述}")
    print()

    # 查看任务的参数和状态
    print("=" * 50)
    print("任务当前参数：")
    for 参数定义 in 任务.元数据.参数列表:
        参数名 = 参数定义.参数名
        print(f"  {参数名} = {getattr(任务.参数, 参数名)}")
    print()

    print("任务当前状态：")
    for 状态定义 in 任务.元数据.状态列表:
        状态名 = 状态定义.状态名
        print(f"  {状态名} = {getattr(任务.状态, 状态名)}")
    print()

    # 修改参数
    print("=" * 50)
    print("修改参数并保存...")
    任务.保存参数(开启刷墙=True, 刷墙起始金币=200000, 优先资源="圣水")

    # 重新加载任务，验证参数是否保存成功
    任务2 = 升级城墙任务_手动(上下文)
    print("重新加载后的参数：")
    print(f"  开启刷墙 = {任务2.参数.开启刷墙}")
    print(f"  刷墙起始金币 = {任务2.参数.刷墙起始金币}")
    print(f"  优先资源 = {任务2.参数.优先资源}")
    print()

    # 执行任务
    print("=" * 50)
    print("执行任务...")
    # 任务.执行()  # 由于依赖模拟器环境，这里注释掉实际执行
